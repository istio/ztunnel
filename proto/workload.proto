// Copyright Istio Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package istio.workload;
option go_package="pkg/workloadapi";

// Address represents a unique address, keyed by IP address and network.
// An Address can represent a Service or an individual workload.
// Address is intended to be able to be looked up on-demand, allowing a workload
// to answer a question like "what is this IP address", similar to a reverse DNS lookup.
// Keyed by network/IP address. Example: "default/1.2.3.4".
//
// In some cases, we do not know the IP address of a Workload. For instance, we may simply know
// that there is a workload behind a gateway, and rely on the gateway to handle the rest.
// In this case, the key format will be "network/resource-uid". The resource can be a Pod, WorkloadEntry, etc.
// These resources cannot be looked up on-demand.
//
// In some cases, we do not know the IP address of a Service. These services cannot be used for matching
// outbound traffic, as we only have L4 attributes to route based on. However,
// they can be used for Gateways.
// In this case, the key format will be "network/hostname".
// These resources cannot be looked up on-demand.
message Address {
  oneof type {
    // Workload represents an individual workload.
    // This could be a single Pod, a VM instance, etc.
    Workload workload = 1;
    // Service represents a service - a group of workloads that can be accessed together.
    Service service = 2;
  }
}

// Service represents a service - a group of workloads that can be accessed together.
message Service {
  // Name represents the name for the service.
  // For Kubernetes, this is the Service name.
  string name = 1;
  // Namespace represents the namespace for the service.
  string namespace = 2;
  // Hostname represents the FQDN of the service.
  // For Kubernetes, this would be <name>.<namespace>.svc.<cluster domain>
  string hostname = 3;
  // Address represents the IPv4/IPv6 address for the service.
  // This should be globally unique.
  // This should not have a port number.
  bytes address = 4;
  // Ports for the service
  repeated Port ports = 5;
  // Optional; if set, the SAN to verify for TLS connections.
  // Typically, this is not set and per-workload identity is used to verfiy
  repeated string subject_alt_name = 6;
}

message Workload {
  // Name represents the name for the workload.
  // For Kubernetes, this is the pod name.
  // This is just for debugging and may be elided as an optimization.
  string name = 1;
  // Namespace represents the namespace for the workload.
  // This is just for debugging and may be elided as an optimization.
  string namespace = 2;

  // Address represents the IPv4/IPv6 address for the workload.
  // This should be globally unique.
  // This should not have a port number.
  bytes address = 3;
  // Network represents the network this workload is on. This may be elided for the default network.
  // A (network,address) pair makeup a unique key for a workload *at a point in time*.
  string network = 4;

  // Protocol that should be used to connect to this workload.
  Protocol protocol = 5;

  // The SPIFFE identity of the workload. The identity is joined to form spiffe://<trust_domain>/ns/<namespace>/sa/<service_account>.
  // TrustDomain of the workload. May be elided if this is the mesh wide default (typically cluster.local)
  string trust_domain = 6;
  // ServiceAccount of the workload. May be elided if this is "default"
  string service_account = 7;

  // If present, the waypoint proxy for this workload.
  // All incoming requests must go through the waypoint.
  GatewayAddress waypoint = 8;

  // If present, East West network gateway this workload can be reached through.
  // Requests from remote networks should traverse this gateway.
  GatewayAddress network_gateway = 19;

  // Name of the node the workload runs on
  string node = 9;

  // CanonicalName for the workload. Used for telemetry.
  string canonical_name = 10;
  // CanonicalRevision for the workload. Used for telemetry.
  string canonical_revision = 11;
  // WorkloadType represents the type of the workload. Used for telemetry.
  WorkloadType workload_type = 12;
  // WorkloadName represents the name for the workload (of type WorkloadType). Used for telemetry.
  string workload_name = 13;

  // If set, indicates this workload directly speaks HBONE, and we should forward HBONE requests as-is.
  bool native_hbone = 14;

  // Virtual IPs defines a set of virtual IP addresses the workload can be reached at.
  // Typically these represent Service ClusterIPs.
  // The key is an IP address.
  map<string, PortList> virtual_ips = 15;

  // A list of authorization policies applicable to this workload.
  // NOTE: this *only* includes Selector based policies. Namespace and global polices
  // are returned out of band.
  repeated string authorization_policies = 16;

  WorkloadStatus status = 17;

  // The cluster ID that the workload instance belongs to
  string cluster_id = 18;
}

enum WorkloadStatus {
  // Workload is healthy and ready to serve traffic.
  HEALTHY = 0;
  // Workload is unhealthy and NOT ready to serve traffic.
  UNHEALTHY = 1;
}

enum WorkloadType {
  DEPLOYMENT = 0;
  CRONJOB = 1;
  POD = 2;
  JOB = 3;
}

// PorList represents the ports for a service
message PortList {
  repeated Port ports = 1;
}

message Port {
  // Port the service is reached at (frontend).
  uint32 service_port = 1;
  // Port the service forwards to (backend).
  uint32 target_port = 2;
}

enum Protocol {
  // DIRECT means requests should be forwarded as-is.
  DIRECT = 0;
  // HTTP means requests should be tunneled over HTTP.
  // This does not dictate HTTP/1.1 vs HTTP/2; ALPN should be used for that purpose.
  HTTP = 1;
}

// GatewayAddres represents the address of a gateway
message GatewayAddress {
  // address can either a hostname (ex: gateway.example.com) or an IP (ex: 1.2.3.4).
  oneof address {
    string hostname = 1;
    bytes ip = 2;
  }
  // port to reach the gateway at
  uint32 port = 3;
}

// Route defines an L4 route rule, allowing rewriting requests to alternative destinations.
message Route {
  message RouteMatch {
    bytes ip = 1;
    uint32 prefix_len = 2;
    uint32 port = 3;
  }
  message SocketAddress {
    bytes ip = 1;
    uint32 port = 2;
  }
  // name of the route
  string name = 1;
  // Matching criteria. When multiple routes are present, the most exact route will be applied first.
  // Only one route may apply to any given connection.
  RouteMatch match = 2;
  // Target is where to send the request to. Note that this is not terminal; if the resolved address
  // is a known Workload or Service, the typical standard behavior for that Workload/Service is applied.
  SocketAddress target = 3;
}